# Изпит, януари 2021 г.

## Въпрос 1
<details>
<summary> Кои системни извиквания работят с файлов дескриптор, създаден с open(2), но ще завършат с грешка за дескриптор, създаден с pipe(2)? Опишете накратко функционалността им. </summary>
<br/>

Системните извиквания ftruncate и lseek не работят с файлов дескриптор, създаден с pipe.

``int ftruncate(int fd, off_t length)`` преоразмерява файл (подаден чрез файловия дескриптор fd) до размер length, като, ако новият размер е повече от стария, след старото съдържание се залепят '\0', а ако новият файл е по-малък, 'излишните' данни се изрязват.
	
``off_t lseek(int fd, off_t offset, int whence)`` премества указателя за текуща позиция на файла с файлов дескриптор fd на offset на брой позиции спрямо отправната точка whence. lseek **не** може да промени размера на файла. Отправната позиция се определя спрямо подадения флаг whence:
  - ``SEEK_SET`` - премества се спрямо началото на файла
  - ``SEEK_CUR`` - премества се спрямо текущата позиция
  - ``SEEK_END`` - премества се спрямо края на файла
	
</details>

## Въпрос 2
<details>
<summary> Опишете накратко функционалността на системни извиквания sem_post(3), sem_wait(3) и sem_trywait(3). </summary>
<br/>
  
Трите извиквания се използват за работа със семафори.

``int sem_post(sem_t *sem)`` увеличава брояча на (отключва) семафорa sem. Aко броячът на sem стане повече от 0, се събужда друг процес, заключен в sem_wait(3), който заключва семафора.
	
``int sem_wait(sem_t *sem)`` намалява брояча на (заключва) семафора sem. Ако броячът на sem е 0, процесът блокира докато декрементирането не стане възможно. sem_wait(3) връща грешка EINTR ако чакането е било прекъснато от сигнал.
	
``int sem_trywait(sem_t *sem)`` е подобно на sem_wait(3), но не блокира, а връща грешка EAGAIN ако семафорът не може да се декрементира веднага (т.е. имал е стойност 0 и е бил заключен).

</details>


# Контролно, ноември 2021 г.

## Въпрос
<details>
<summary> Какви са приликите и разликите при работа на системните извиквания open(2) и link(2)? Опишете накратко функционалността им.</summary>
<br/>

``int open(const char* pathname, int flags, mode_t mode)`` отваря файл.

В процеса на отваряне се създава указател към текущата позиция във файла (в началото).  Чрез open може да се създаде и нов файл, като тогава mode е кодът на защита на новосъздадения файл.
	
Задава се точно един от флаговете, указващи режим на отваряне - ``O_RDONLY`` (само за четене), ``O_WRONLY`` (само за писане), ``O_RDWR`` (за четене и писане).

Други флагове:
  - ``O_APPEND`` - указателят към текущата позиция се премества в края на файла
  - ``O_TRUNC`` - ако вече има такъв файл, той се изтрива
  - ``O_CREAT`` - създава се нов файл, ако такъв не съществува
	
``int link(const char *oldname, const char *newname)`` създава твърда връзка за съществуващ файл. Твърдата връзка създава ново име на файл, но се свързва към i-node на съществуващия вече файл, като в i-node се увеличава броят на твърдите връзки.

**Прилика:** и с двете се създава ново име на файл

**Разлика:** при link нямаме "реален" нов файл, а твърда връзка към i-node съществуващ файл

</details>

