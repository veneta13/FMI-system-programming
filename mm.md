# Изпит, януари 2021 г.

## Въпрос 1
<details>
<summary> Кои системни извиквания работят с файлов дескриптор, създаден с open(2), но ще завършат с грешка за дескриптор, създаден с pipe(2)? Опишете накратко функционалността им. </summary>
<br/>

Системните извиквания ftruncate и lseek не работят с файлов дескриптор, създаден с pipe.

``int ftruncate(int fd, off_t length)`` преоразмерява файл (подаден чрез файловия дескриптор fd) до размер length, като, ако новият размер е повече от стария, след старото съдържание се залепят '\0', а ако новият файл е по-малък, 'излишните' данни се изрязват.
	
``off_t lseek(int fd, off_t offset, int whence)`` премества указателя за текуща позиция на файла с файлов дескриптор fd на offset на брой позиции спрямо отправната точка whence. lseek **не** може да промени размера на файла. Отправната позиция се определя спрямо подадения флаг whence:
  - ``SEEK_SET`` - премества се спрямо началото на файла
  - ``SEEK_CUR`` - премества се спрямо текущата позиция
  - ``SEEK_END`` - премества се спрямо края на файла
	
</details>

## Въпрос 2
<details>
<summary> Опишете накратко функционалността на системни извиквания sem_post(3), sem_wait(3) и sem_trywait(3). </summary>
<br/>
  
Трите извиквания се използват за работа със семафори.

``int sem_post(sem_t *sem)`` увеличава брояча на (отключва) семафорa sem. Aко броячът на sem стане повече от 0, се събужда друг процес, заключен в sem_wait(3), който заключва семафора.
	
``int sem_wait(sem_t *sem)`` намалява брояча на (заключва) семафора sem. Ако броячът на sem е 0, процесът блокира докато декрементирането не стане възможно. sem_wait(3) връща грешка EINTR ако чакането е било прекъснато от сигнал.
	
``int sem_trywait(sem_t *sem)`` е подобно на sem_wait(3), но не блокира, а връща грешка EAGAIN ако семафорът не може да се декрементира веднага (т.е. имал е стойност 0 и е бил заключен).

</details>
